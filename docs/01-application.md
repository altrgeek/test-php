# The application

Currently there are 4 services deployed on the compute engine VM including a [Laravel](https://laravel.com) web application, a [Flask](https://flask.palletsprojects.com) API, a websocket server ([Soketi](https://soketi.app)) and an [NGINX](https://www.nginx.com) instance acting as a reverse proxy, a load balancer and SSL certificates manager. All 4 applications are containerized using [Docker](https://www.docker.com) and are running via [Docker Compose](https://docs.docker.com/compose).

## Local development environment
The local development environment is setup using a Docker compose spec file (`docker-compose.yml`) which consists of necessary services for development, testing and debugging the application including NGINX web server, MariaDB database, Redis instance, Soketi websocket server, phpMyAdmin database manager and MailHog email tester. The application service uses a minimal Docker image with necessary packages pre-installed for development including [`composer`](https://getcomposer.org), [`php`](https://www.php.net) version 8.1 (with extensions like `gmp`, `grpc`, `imagick`, `mysql`, `redis`, `xdebug` and others, see [`docker/Dockerfile.local`](../docker/Dockerfile.local)) and [`node`](https://nodejs.org) version 16. The image utilizes [`supervisor`](http://supervisord.org) for starting the Laravel application, [`vite`](https://vitejs.dev) development server, Laravel queue processing workers and Laravel cron job processor. The image mounts the current working directory into the container for hot reloading and instant response. The compose spec only exposes the NGINX service to public, make sure the ports are free on host machine before starting the compose projects (check `nginx` service in `docker-compose.yml` file for ports).

The application services can be started by using `docker compose up` command in the application directory. Before starting the application make sure you've properly setup the Docker environment, the Docker Compose plugin and all required ports are not being used by other applications.

Note that the `emotion` (AI emotion detection API) may or may not be included in the development compose specification as it is decoupled from current codebase and maintained as a standalone project in a separate repository.

## Production environment
The production environment pulls pre-built images from the container registry and boots up application providing appropriate environment and secrets. The production container image is built using the `Dockerfile` Docker build file. All assets and blade views are pre-compiled and cached in the image for better performance so editing code inside the production container will not be reflected. The production compose spec file, environment configurations and deployment scripts are maintained on a separate repository. It uses web portal, emotion API, Redis cache, socket server and NGINX server only and the remaining services are being consumed from the cloud over dedicated plans.
